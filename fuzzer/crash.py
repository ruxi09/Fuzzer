from typing import Tuple, Optional, List
from dataclasses import dataclass
from enum import Enum
import re


# The most common crash types reported by ASan and UBSan
class CrashType(Enum):
    # ASan
    ASAN_NULL_PTR = 0
    ASAN_INVALID_PTR = 1
    ASAN_BUFFER_OVERFLOW = 2
    ASAN_BUFFER_UNDERFLOW = 3
    ASAN_DOUBLE_FREE = 4
    ASAN_USE_AFTER_FREE = 5
    ASAN_INVALID_STACK_USE = 6
    ASAN_GENERAL_ERROR = 7
    ASAN_ALLOCATION_INVALID = 8

    #UBSan
    UBSAN_GENERAL_ERROR = 9
    UBSAN_NUMBER_OVERFLOW = 10
    UBSAN_MISALIGNED_RW = 11
    UBSAN_NULL_PTR = 12


@dataclass
class Crash:
    """
    Represents a crash type and the offending location in the source code.
    """
    crash_type: Optional[CrashType]
    offending_line: Optional[str]

    def __hash__(self):
        return hash((str(self.crash_type), self.offending_line))


class ProgramCrash:
    """
    Represents the crash message(s) generated by running the program from both
    AddressSanitizer and UndefinedBehaviorSanitizer.
    """
    asan_crash: Optional[Crash]
    ubsan_crashes: Optional[List[Crash]]

    def __init__(self, _asan_crash: Optional[Crash], _ubsan_crashes: Optional[List[Crash]]):
        self.asan_crash = _asan_crash
        self.ubsan_crashes = _ubsan_crashes

    def __hash__(self):
        asan_crash_hash = hash(self.asan_crash)
        ubsan_crashes_hash = 0
        if self.ubsan_crashes is not None:
            for crash in self.ubsan_crashes:
                ubsan_crashes_hash ^= hash(crash)
            return asan_crash_hash ^ ubsan_crashes_hash
        return asan_crash_hash

    def __str__(self):
        return f"ProgramCrash( ASan = {self.asan_crash} , UBSan = {self.ubsan_crashes} )"
    
    def __eq__(self, other):
        if self.asan_crash != other.asan_crash:
            return False
        if self.ubsan_crashes is None and other.ubsan_crashes is None:
            return True
        if self.ubsan_crashes is None or other.ubsan_crashes is None:
            return False
        if len(self.ubsan_crashes) != len(other.ubsan_crashes):
            return False
        for i in range(len(self.ubsan_crashes)):
            if self.ubsan_crashes[i] != other.ubsan_crashes[i]:
                return False
        return True


def analyse_program_crash(output: str) -> Optional[ProgramCrash]:
    """
    Analyse the output message and build a ProgramCrash object.
    """

    ubsan_crashes = get_ubsan_crashes_info(output)
    asan_crash = get_asan_crash_info(output)

    if asan_crash or ubsan_crashes:
        return ProgramCrash(asan_crash, ubsan_crashes)

    return None


def get_ubsan_crashes_info(output: str) -> Optional[List[Crash]]:
    """
    Extract the crash information generated by UndefinedBehaviorSanitizer.
    """

    lines = output.split("\n")
    errors = []
    for line in lines:
        if "runtime error" in line:
            ty = CrashType.UBSAN_GENERAL_ERROR
            if "null" in line:
                ty = CrashType.UBSAN_NULL_PTR
            elif "misaligned" in line:
                ty = CrashType.UBSAN_MISALIGNED_RW
            elif "overflow" in line:
                ty = CrashType.UBSAN_NUMBER_OVERFLOW
            source_location = line.split()[0]
            errors.append(Crash(ty, source_location))

    if len(errors) == 0:
        return None
    
    return errors


def get_asan_crash_info(output: str) -> Optional[Crash]:
    """
    Extract the crash information generated by AddressSanitizer.
    """

    crash = detect_asan_crash_type_and_location(output)
    if crash is None:
        return crash
    return Crash(crash[0], crash[1])


def parse_asan_source_location(stderr: str) -> str:
    """
    Parse the source location which caused the crash (from ASan message).
    """

    lines = stderr.split('\n')
    for line in lines:
        if line.startswith("SUMMARY"):
            m = re.search(r"\w+\.\w+:\d+", line)
            if m:
                src_location = m.group()
                return src_location

    return ""


def detect_asan_crash_type_and_location(stderr: str) -> Optional[Tuple[CrashType, str]]:
    """
    Parses the crash type from the message in stderr. Returns None if it did not crash.
    """

    if "AddressSanitizer" in stderr:
        source_location = parse_asan_source_location(stderr)

        if "SEGV on unknown address 0x000000000" in stderr:
            return CrashType.ASAN_NULL_PTR, source_location
        elif "SEGV on unknown address" in stderr:
            return CrashType.ASAN_INVALID_PTR, source_location
        elif "buffer-overflow" in stderr:
            return CrashType.ASAN_BUFFER_OVERFLOW, source_location
        elif "buffer-underflow" in stderr:
            return CrashType.ASAN_BUFFER_UNDERFLOW, source_location
        elif  "double-free" in stderr:
            return CrashType.ASAN_DOUBLE_FREE, source_location
        elif "use-after-free" in stderr:
            return CrashType.ASAN_USE_AFTER_FREE, source_location
        elif "stack-use-after" in stderr:
            return CrashType.ASAN_INVALID_STACK_USE, source_location
        elif "allocation-size-too-big" in stderr:
            return CrashType.ASAN_ALLOCATION_INVALID, source_location
        else:
            return CrashType.ASAN_GENERAL_ERROR, source_location

    return None
